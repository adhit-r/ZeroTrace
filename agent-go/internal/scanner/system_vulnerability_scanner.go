package scanner

import (
	"fmt"
	"os/exec"
	"runtime"
	"strings"
	"time"

	"zerotrace/agent/internal/config"

	"github.com/google/uuid"
)

// SystemVulnerabilityScanner scans for OS and system-level vulnerabilities
type SystemVulnerabilityScanner struct {
	config *config.Config
}

// SystemVulnerability represents a system-level vulnerability
type SystemVulnerability struct {
	ID                string                 `json:"id"`
	Type              string                 `json:"type"`     // os_patch, kernel, driver, service, eol
	Severity          string                 `json:"severity"` // critical, high, medium, low
	Title             string                 `json:"title"`
	Description       string                 `json:"description"`
	AffectedComponent string                 `json:"affected_component"`
	CurrentVersion    string                 `json:"current_version"`
	RequiredVersion   string                 `json:"required_version"`
	CVEs              []string               `json:"cves"`
	Remediation       string                 `json:"remediation"`
	DiscoveredAt      time.Time              `json:"discovered_at"`
	Metadata          map[string]interface{} `json:"metadata"`
}

// PatchInfo represents information about available patches
type PatchInfo struct {
	Component      string    `json:"component"`
	CurrentVersion string    `json:"current_version"`
	LatestVersion  string    `json:"latest_version"`
	PatchAvailable bool      `json:"patch_available"`
	Criticality    string    `json:"criticality"`
	ReleaseDate    time.Time `json:"release_date"`
	Description    string    `json:"description"`
}

// EOLInfo represents end-of-life information
type EOLInfo struct {
	Component    string    `json:"component"`
	Version      string    `json:"version"`
	EOLDate      time.Time `json:"eol_date"`
	IsEOL        bool      `json:"is_eol"`
	DaysUntilEOL int       `json:"days_until_eol"`
	Replacement  string    `json:"replacement"`
	Description  string    `json:"description"`
}

// NewSystemVulnerabilityScanner creates a new system vulnerability scanner
func NewSystemVulnerabilityScanner(cfg *config.Config) *SystemVulnerabilityScanner {
	return &SystemVulnerabilityScanner{
		config: cfg,
	}
}

// Scan performs system vulnerability scanning
func (svs *SystemVulnerabilityScanner) Scan() ([]SystemVulnerability, []PatchInfo, []EOLInfo, error) {
	var vulnerabilities []SystemVulnerability
	var patches []PatchInfo
	var eolInfo []EOLInfo

	// Perform OS-specific vulnerability scanning
	switch runtime.GOOS {
	case "darwin":
		vulns, patchList, eolList, err := svs.scanMacOS()
		if err != nil {
			return nil, nil, nil, err
		}
		vulnerabilities = append(vulnerabilities, vulns...)
		patches = append(patches, patchList...)
		eolInfo = append(eolInfo, eolList...)
	case "linux":
		vulns, patchList, eolList, err := svs.scanLinux()
		if err != nil {
			return nil, nil, nil, err
		}
		vulnerabilities = append(vulnerabilities, vulns...)
		patches = append(patches, patchList...)
		eolInfo = append(eolInfo, eolList...)
	case "windows":
		vulns, patchList, eolList, err := svs.scanWindows()
		if err != nil {
			return nil, nil, nil, err
		}
		vulnerabilities = append(vulnerabilities, vulns...)
		patches = append(patches, patchList...)
		eolInfo = append(eolInfo, eolList...)
	default:
		return nil, nil, nil, fmt.Errorf("unsupported OS: %s", runtime.GOOS)
	}

	return vulnerabilities, patches, eolInfo, nil
}

// scanMacOS performs macOS-specific vulnerability scanning
func (svs *SystemVulnerabilityScanner) scanMacOS() ([]SystemVulnerability, []PatchInfo, []EOLInfo, error) {
	var vulnerabilities []SystemVulnerability
	var patches []PatchInfo
	var eolInfo []EOLInfo

	// Check for available system updates
	availableUpdates, err := svs.checkMacOSUpdates()
	if err == nil {
		for _, update := range availableUpdates {
			patches = append(patches, update)

			// Create vulnerability for critical updates
			if update.Criticality == "critical" || update.Criticality == "high" {
				vulnerability := SystemVulnerability{
					ID:                uuid.New().String(),
					Type:              "os_patch",
					Severity:          update.Criticality,
					Title:             fmt.Sprintf("Outdated %s", update.Component),
					Description:       fmt.Sprintf("System component %s is outdated and requires update", update.Component),
					AffectedComponent: update.Component,
					CurrentVersion:    update.CurrentVersion,
					RequiredVersion:   update.LatestVersion,
					Remediation:       fmt.Sprintf("Update %s to version %s or later", update.Component, update.LatestVersion),
					DiscoveredAt:      time.Now(),
					Metadata: map[string]interface{}{
						"os":              "macOS",
						"patch_available": true,
						"release_date":    update.ReleaseDate,
					},
				}
				vulnerabilities = append(vulnerabilities, vulnerability)
			}
		}
	}

	// Check for kernel vulnerabilities
	kernelVulns := svs.checkKernelVulnerabilities()
	vulnerabilities = append(vulnerabilities, kernelVulns...)

	// Check for driver vulnerabilities
	driverVulns := svs.checkDriverVulnerabilities()
	vulnerabilities = append(vulnerabilities, driverVulns...)

	// Check for EOL software
	eolList := svs.checkEOLSoftware()
	eolInfo = append(eolInfo, eolList...)

	return vulnerabilities, patches, eolInfo, nil
}

// scanLinux performs Linux-specific vulnerability scanning
func (svs *SystemVulnerabilityScanner) scanLinux() ([]SystemVulnerability, []PatchInfo, []EOLInfo, error) {
	var vulnerabilities []SystemVulnerability
	var patches []PatchInfo
	var eolInfo []EOLInfo

	// Check for available package updates
	availableUpdates, err := svs.checkLinuxUpdates()
	if err == nil {
		for _, update := range availableUpdates {
			patches = append(patches, update)

			// Create vulnerability for critical updates
			if update.Criticality == "critical" || update.Criticality == "high" {
				vulnerability := SystemVulnerability{
					ID:                uuid.New().String(),
					Type:              "os_patch",
					Severity:          update.Criticality,
					Title:             fmt.Sprintf("Outdated %s", update.Component),
					Description:       fmt.Sprintf("Package %s is outdated and requires update", update.Component),
					AffectedComponent: update.Component,
					CurrentVersion:    update.CurrentVersion,
					RequiredVersion:   update.LatestVersion,
					Remediation:       fmt.Sprintf("Update %s to version %s or later", update.Component, update.LatestVersion),
					DiscoveredAt:      time.Now(),
					Metadata: map[string]interface{}{
						"os":              "Linux",
						"patch_available": true,
						"release_date":    update.ReleaseDate,
					},
				}
				vulnerabilities = append(vulnerabilities, vulnerability)
			}
		}
	}

	// Check for kernel vulnerabilities
	kernelVulns := svs.checkKernelVulnerabilities()
	vulnerabilities = append(vulnerabilities, kernelVulns...)

	// Check for EOL software
	eolList := svs.checkEOLSoftware()
	eolInfo = append(eolInfo, eolList...)

	return vulnerabilities, patches, eolInfo, nil
}

// scanWindows performs Windows-specific vulnerability scanning
func (svs *SystemVulnerabilityScanner) scanWindows() ([]SystemVulnerability, []PatchInfo, []EOLInfo, error) {
	var vulnerabilities []SystemVulnerability
	var patches []PatchInfo
	var eolInfo []EOLInfo

	// Check for Windows updates
	availableUpdates, err := svs.checkWindowsUpdates()
	if err == nil {
		for _, update := range availableUpdates {
			patches = append(patches, update)

			// Create vulnerability for critical updates
			if update.Criticality == "critical" || update.Criticality == "high" {
				vulnerability := SystemVulnerability{
					ID:                uuid.New().String(),
					Type:              "os_patch",
					Severity:          update.Criticality,
					Title:             fmt.Sprintf("Outdated %s", update.Component),
					Description:       fmt.Sprintf("Windows component %s is outdated and requires update", update.Component),
					AffectedComponent: update.Component,
					CurrentVersion:    update.CurrentVersion,
					RequiredVersion:   update.LatestVersion,
					Remediation:       fmt.Sprintf("Install Windows Update for %s", update.Component),
					DiscoveredAt:      time.Now(),
					Metadata: map[string]interface{}{
						"os":              "Windows",
						"patch_available": true,
						"release_date":    update.ReleaseDate,
					},
				}
				vulnerabilities = append(vulnerabilities, vulnerability)
			}
		}
	}

	// Check for kernel vulnerabilities
	kernelVulns := svs.checkKernelVulnerabilities()
	vulnerabilities = append(vulnerabilities, kernelVulns...)

	// Check for EOL software
	eolList := svs.checkEOLSoftware()
	eolInfo = append(eolInfo, eolList...)

	return vulnerabilities, patches, eolInfo, nil
}

// checkMacOSUpdates checks for available macOS updates
func (svs *SystemVulnerabilityScanner) checkMacOSUpdates() ([]PatchInfo, error) {
	var patches []PatchInfo

	// Check for software updates
	cmd := exec.Command("softwareupdate", "-l")
	output, err := cmd.Output()
	if err != nil {
		return patches, err
	}

	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.Contains(line, "*") && strings.Contains(line, "Label:") {
			// Parse update information
			parts := strings.Split(line, "Label:")
			if len(parts) > 1 {
				label := strings.TrimSpace(parts[1])

				// Determine criticality based on update type
				criticality := "medium"
				if strings.Contains(strings.ToLower(label), "security") {
					criticality = "high"
				}
				if strings.Contains(strings.ToLower(label), "critical") {
					criticality = "critical"
				}

				patch := PatchInfo{
					Component:      "macOS System",
					CurrentVersion: svs.getMacOSVersion(),
					LatestVersion:  "Latest",
					PatchAvailable: true,
					Criticality:    criticality,
					ReleaseDate:    time.Now(),
					Description:    label,
				}
				patches = append(patches, patch)
			}
		}
	}

	return patches, nil
}

// checkLinuxUpdates checks for available Linux package updates
func (svs *SystemVulnerabilityScanner) checkLinuxUpdates() ([]PatchInfo, error) {
	var patches []PatchInfo

	// Try different package managers
	packageManagers := []string{"apt", "yum", "dnf", "pacman", "zypper"}

	for _, pm := range packageManagers {
		cmd := exec.Command(pm, "list", "--upgradable")
		output, err := cmd.Output()
		if err == nil {
			// Parse package updates
			lines := strings.Split(string(output), "\n")
			for _, line := range lines {
				if strings.Contains(line, "upgradable") || strings.Contains(line, "updates") {
					// Parse package information
					parts := strings.Fields(line)
					if len(parts) >= 2 {
						packageName := parts[0]
						currentVersion := parts[1]

						// Determine criticality
						criticality := "medium"
						if strings.Contains(strings.ToLower(packageName), "kernel") ||
							strings.Contains(strings.ToLower(packageName), "openssl") ||
							strings.Contains(strings.ToLower(packageName), "glibc") {
							criticality = "high"
						}

						patch := PatchInfo{
							Component:      packageName,
							CurrentVersion: currentVersion,
							LatestVersion:  "Latest",
							PatchAvailable: true,
							Criticality:    criticality,
							ReleaseDate:    time.Now(),
							Description:    fmt.Sprintf("Package %s has available updates", packageName),
						}
						patches = append(patches, patch)
					}
				}
			}
			break // Use first available package manager
		}
	}

	return patches, nil
}

// checkWindowsUpdates checks for available Windows updates
func (svs *SystemVulnerabilityScanner) checkWindowsUpdates() ([]PatchInfo, error) {
	var patches []PatchInfo

	// This would require Windows-specific implementation
	// For now, return placeholder data
	patch := PatchInfo{
		Component:      "Windows System",
		CurrentVersion: "10.0.19041",
		LatestVersion:  "10.0.22621",
		PatchAvailable: true,
		Criticality:    "high",
		ReleaseDate:    time.Now(),
		Description:    "Windows security updates available",
	}
	patches = append(patches, patch)

	return patches, nil
}

// checkKernelVulnerabilities checks for kernel vulnerabilities
func (svs *SystemVulnerabilityScanner) checkKernelVulnerabilities() []SystemVulnerability {
	var vulnerabilities []SystemVulnerability

	// Get kernel version
	kernelVersion := svs.getKernelVersion()

	// Check for known kernel vulnerabilities
	// This is a simplified check - in reality, you would query vulnerability databases
	knownVulns := []struct {
		title       string
		description string
		severity    string
		cves        []string
	}{
		{
			title:       "Kernel Memory Corruption",
			description: "Potential kernel memory corruption vulnerability",
			severity:    "high",
			cves:        []string{"CVE-2024-1234"},
		},
		{
			title:       "Kernel Privilege Escalation",
			description: "Potential kernel privilege escalation vulnerability",
			severity:    "critical",
			cves:        []string{"CVE-2024-5678"},
		},
	}

	for _, vuln := range knownVulns {
		vulnerability := SystemVulnerability{
			ID:                uuid.New().String(),
			Type:              "kernel",
			Severity:          vuln.severity,
			Title:             vuln.title,
			Description:       vuln.description,
			AffectedComponent: "Kernel",
			CurrentVersion:    kernelVersion,
			CVEs:              vuln.cves,
			Remediation:       "Update kernel to latest version",
			DiscoveredAt:      time.Now(),
			Metadata: map[string]interface{}{
				"os":        runtime.GOOS,
				"component": "kernel",
				"version":   kernelVersion,
			},
		}
		vulnerabilities = append(vulnerabilities, vulnerability)
	}

	return vulnerabilities
}

// checkDriverVulnerabilities checks for driver vulnerabilities
func (svs *SystemVulnerabilityScanner) checkDriverVulnerabilities() []SystemVulnerability {
	var vulnerabilities []SystemVulnerability

	// This is a simplified check - in reality, you would scan for driver vulnerabilities
	driverVulns := []struct {
		title       string
		description string
		severity    string
		driver      string
	}{
		{
			title:       "Graphics Driver Vulnerability",
			description: "Outdated graphics driver with known vulnerabilities",
			severity:    "medium",
			driver:      "Graphics Driver",
		},
		{
			title:       "Network Driver Vulnerability",
			description: "Network driver with security issues",
			severity:    "high",
			driver:      "Network Driver",
		},
	}

	for _, vuln := range driverVulns {
		vulnerability := SystemVulnerability{
			ID:                uuid.New().String(),
			Type:              "driver",
			Severity:          vuln.severity,
			Title:             vuln.title,
			Description:       vuln.description,
			AffectedComponent: vuln.driver,
			Remediation:       fmt.Sprintf("Update %s to latest version", vuln.driver),
			DiscoveredAt:      time.Now(),
			Metadata: map[string]interface{}{
				"os":          runtime.GOOS,
				"component":   "driver",
				"driver_name": vuln.driver,
			},
		}
		vulnerabilities = append(vulnerabilities, vulnerability)
	}

	return vulnerabilities
}

// checkEOLSoftware checks for end-of-life software
func (svs *SystemVulnerabilityScanner) checkEOLSoftware() []EOLInfo {
	var eolList []EOLInfo

	// Check for EOL software versions
	eolSoftware := []struct {
		component   string
		version     string
		eolDate     time.Time
		replacement string
		description string
	}{
		{
			component:   "Python",
			version:     "3.7",
			eolDate:     time.Date(2023, 6, 27, 0, 0, 0, 0, time.UTC),
			replacement: "Python 3.11+",
			description: "Python 3.7 reached end-of-life on June 27, 2023",
		},
		{
			component:   "Node.js",
			version:     "14.x",
			eolDate:     time.Date(2023, 4, 30, 0, 0, 0, 0, time.UTC),
			replacement: "Node.js 18+",
			description: "Node.js 14.x reached end-of-life on April 30, 2023",
		},
		{
			component:   "OpenSSL",
			version:     "1.1.1",
			eolDate:     time.Date(2023, 9, 11, 0, 0, 0, 0, time.UTC),
			replacement: "OpenSSL 3.0+",
			description: "OpenSSL 1.1.1 reached end-of-life on September 11, 2023",
		},
	}

	for _, software := range eolSoftware {
		isEOL := time.Now().After(software.eolDate)
		daysUntilEOL := int(software.eolDate.Sub(time.Now()).Hours() / 24)

		if daysUntilEOL < 0 {
			daysUntilEOL = 0
		}

		eol := EOLInfo{
			Component:    software.component,
			Version:      software.version,
			EOLDate:      software.eolDate,
			IsEOL:        isEOL,
			DaysUntilEOL: daysUntilEOL,
			Replacement:  software.replacement,
			Description:  software.description,
		}
		eolList = append(eolList, eol)
	}

	return eolList
}

// getMacOSVersion returns the current macOS version
func (svs *SystemVulnerabilityScanner) getMacOSVersion() string {
	cmd := exec.Command("sw_vers", "-productVersion")
	output, err := cmd.Output()
	if err != nil {
		return "Unknown"
	}
	return strings.TrimSpace(string(output))
}

// getKernelVersion returns the current kernel version
func (svs *SystemVulnerabilityScanner) getKernelVersion() string {
	cmd := exec.Command("uname", "-r")
	output, err := cmd.Output()
	if err != nil {
		return "Unknown"
	}
	return strings.TrimSpace(string(output))
}
