-- 003_enhanced_vulnerability_schema.sql
-- Enhanced vulnerability schema for comprehensive security scanning
-- Supports network, compliance, system, auth, database, API, container, AI/ML, IoT, privacy, and Web3 security

BEGIN;

-- Create extensions if not exists
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "pg_stat_statements";

-- ============================================================================
-- ENHANCED VULNERABILITY TABLES
-- ============================================================================

-- Enhanced vulnerabilities table with comprehensive security categories
CREATE TABLE vulnerabilities_v2 (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    organization_id UUID,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    severity VARCHAR(20) NOT NULL CHECK (severity IN ('critical', 'high', 'medium', 'low', 'info')),
    category VARCHAR(50) NOT NULL CHECK (category IN (
        'application', 'network', 'configuration', 'system', 'auth', 
        'database', 'api', 'container', 'ai', 'iot', 'privacy', 'web3'
    )),
    status VARCHAR(50) DEFAULT 'open' CHECK (status IN ('open', 'resolved', 'mitigated', 'false_positive')),
    discovered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_seen TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    risk_score DECIMAL(3,2) DEFAULT 0.0,
    exploit_complexity VARCHAR(20) CHECK (exploit_complexity IN ('low', 'medium', 'high')),
    attack_vector VARCHAR(50),
    compliance_frameworks JSONB DEFAULT '[]',
    remediation TEXT,
    references JSONB DEFAULT '[]',
    tags JSONB DEFAULT '[]',
    metadata JSONB DEFAULT '{}',
    enrichment_data JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Network security findings
CREATE TABLE network_findings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    scan_id UUID,
    host VARCHAR(255) NOT NULL,
    port INTEGER NOT NULL,
    protocol VARCHAR(10) NOT NULL,
    service_name VARCHAR(100),
    service_version VARCHAR(100),
    banner TEXT,
    ssl_enabled BOOLEAN DEFAULT FALSE,
    ssl_version VARCHAR(20),
    ssl_cipher VARCHAR(100),
    ssl_certificate_issuer VARCHAR(255),
    ssl_certificate_expiry TIMESTAMP WITH TIME ZONE,
    vulnerability_count INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'open',
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Compliance checks
CREATE TABLE compliance_checks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    framework VARCHAR(50) NOT NULL CHECK (framework IN ('CIS', 'PCI-DSS', 'HIPAA', 'GDPR', 'SOC2', 'ISO27001')),
    category VARCHAR(100) NOT NULL,
    requirement VARCHAR(500) NOT NULL,
    status VARCHAR(20) NOT NULL CHECK (status IN ('pass', 'fail', 'not_applicable', 'error')),
    severity VARCHAR(20) CHECK (severity IN ('critical', 'high', 'medium', 'low', 'info')),
    description TEXT,
    remediation TEXT,
    evidence JSONB DEFAULT '{}',
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- System vulnerabilities (OS, kernel, drivers)
CREATE TABLE system_vulnerabilities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    vulnerability_type VARCHAR(50) NOT NULL CHECK (vulnerability_type IN ('os_patch', 'kernel', 'driver', 'eol_software')),
    os_name VARCHAR(100),
    os_version VARCHAR(100),
    component_name VARCHAR(255),
    component_version VARCHAR(100),
    cve_id VARCHAR(20),
    severity VARCHAR(20) NOT NULL,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    remediation TEXT,
    patch_available BOOLEAN DEFAULT FALSE,
    patch_url VARCHAR(500),
    eol_date DATE,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Authentication security findings
CREATE TABLE auth_findings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    finding_type VARCHAR(50) NOT NULL CHECK (finding_type IN ('password_policy', 'account_security', 'privilege_escalation', 'auth_bypass')),
    user_account VARCHAR(255),
    severity VARCHAR(20) NOT NULL,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    risk_score DECIMAL(3,2) DEFAULT 0.0,
    remediation TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Database security findings
CREATE TABLE database_findings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    database_type VARCHAR(50) NOT NULL CHECK (database_type IN ('postgresql', 'mysql', 'mongodb', 'redis', 'sqlserver', 'oracle')),
    host VARCHAR(255) NOT NULL,
    port INTEGER,
    database_name VARCHAR(100),
    finding_type VARCHAR(50) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    remediation TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API security findings
CREATE TABLE api_findings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    api_type VARCHAR(20) NOT NULL CHECK (api_type IN ('REST', 'GraphQL', 'SOAP', 'gRPC')),
    endpoint VARCHAR(500) NOT NULL,
    method VARCHAR(10),
    finding_type VARCHAR(50) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    remediation TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Container security findings
CREATE TABLE container_findings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    container_id VARCHAR(100),
    image_name VARCHAR(255),
    image_tag VARCHAR(100),
    finding_type VARCHAR(50) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    remediation TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- AI/ML security findings
CREATE TABLE ai_ml_findings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    finding_type VARCHAR(50) NOT NULL CHECK (finding_type IN ('model_vulnerability', 'training_data', 'llm_security', 'bias_fairness')),
    model_name VARCHAR(255),
    model_version VARCHAR(100),
    framework VARCHAR(100),
    severity VARCHAR(20) NOT NULL,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    remediation TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- IoT/OT security findings
CREATE TABLE iot_ot_findings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    device_type VARCHAR(50) NOT NULL,
    device_id VARCHAR(100),
    protocol VARCHAR(20),
    finding_type VARCHAR(50) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    remediation TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Privacy and compliance findings
CREATE TABLE privacy_findings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    finding_type VARCHAR(50) NOT NULL CHECK (finding_type IN ('pii_detection', 'gdpr_compliance', 'ccpa_compliance', 'data_retention')),
    data_type VARCHAR(50),
    location VARCHAR(500),
    severity VARCHAR(20) NOT NULL,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    remediation TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Web3 security findings
CREATE TABLE web3_findings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id UUID NOT NULL,
    company_id UUID NOT NULL,
    finding_type VARCHAR(50) NOT NULL CHECK (finding_type IN ('smart_contract', 'wallet_security', 'dapp_security', 'defi_risks')),
    contract_address VARCHAR(100),
    network VARCHAR(50),
    severity VARCHAR(20) NOT NULL,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    remediation TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================================================
-- PARTITIONING FOR PERFORMANCE
-- ============================================================================

-- Partition vulnerabilities_v2 by company_id
CREATE TABLE vulnerabilities_v2_partitioned (
    LIKE vulnerabilities_v2 INCLUDING ALL
) PARTITION BY HASH (company_id);

-- Create partitions for vulnerabilities_v2
CREATE TABLE vulnerabilities_v2_partition_0 PARTITION OF vulnerabilities_v2_partitioned
    FOR VALUES WITH (modulus 4, remainder 0);
CREATE TABLE vulnerabilities_v2_partition_1 PARTITION OF vulnerabilities_v2_partitioned
    FOR VALUES WITH (modulus 4, remainder 1);
CREATE TABLE vulnerabilities_v2_partition_2 PARTITION OF vulnerabilities_v2_partitioned
    FOR VALUES WITH (modulus 4, remainder 2);
CREATE TABLE vulnerabilities_v2_partition_3 PARTITION OF vulnerabilities_v2_partitioned
    FOR VALUES WITH (modulus 4, remainder 3);

-- Partition network_findings by company_id
CREATE TABLE network_findings_partitioned (
    LIKE network_findings INCLUDING ALL
) PARTITION BY HASH (company_id);

CREATE TABLE network_findings_partition_0 PARTITION OF network_findings_partitioned
    FOR VALUES WITH (modulus 4, remainder 0);
CREATE TABLE network_findings_partition_1 PARTITION OF network_findings_partitioned
    FOR VALUES WITH (modulus 4, remainder 1);
CREATE TABLE network_findings_partition_2 PARTITION OF network_findings_partitioned
    FOR VALUES WITH (modulus 4, remainder 2);
CREATE TABLE network_findings_partition_3 PARTITION OF network_findings_partitioned
    FOR VALUES WITH (modulus 4, remainder 3);

-- Partition compliance_checks by company_id
CREATE TABLE compliance_checks_partitioned (
    LIKE compliance_checks INCLUDING ALL
) PARTITION BY HASH (company_id);

CREATE TABLE compliance_checks_partition_0 PARTITION OF compliance_checks_partitioned
    FOR VALUES WITH (modulus 4, remainder 0);
CREATE TABLE compliance_checks_partition_1 PARTITION OF compliance_checks_partitioned
    FOR VALUES WITH (modulus 4, remainder 1);
CREATE TABLE compliance_checks_partition_2 PARTITION OF compliance_checks_partitioned
    FOR VALUES WITH (modulus 4, remainder 2);
CREATE TABLE compliance_checks_partition_3 PARTITION OF compliance_checks_partitioned
    FOR VALUES WITH (modulus 4, remainder 3);

-- ============================================================================
-- INDEXES FOR PERFORMANCE
-- ============================================================================

-- Vulnerabilities v2 indexes
CREATE INDEX idx_vulnerabilities_v2_agent_id ON vulnerabilities_v2_partitioned(agent_id);
CREATE INDEX idx_vulnerabilities_v2_company_id ON vulnerabilities_v2_partitioned(company_id);
CREATE INDEX idx_vulnerabilities_v2_severity ON vulnerabilities_v2_partitioned(severity);
CREATE INDEX idx_vulnerabilities_v2_category ON vulnerabilities_v2_partitioned(category);
CREATE INDEX idx_vulnerabilities_v2_status ON vulnerabilities_v2_partitioned(status);
CREATE INDEX idx_vulnerabilities_v2_risk_score ON vulnerabilities_v2_partitioned(risk_score);
CREATE INDEX idx_vulnerabilities_v2_discovered_at ON vulnerabilities_v2_partitioned(discovered_at);
CREATE INDEX idx_vulnerabilities_v2_company_severity ON vulnerabilities_v2_partitioned(company_id, severity);
CREATE INDEX idx_vulnerabilities_v2_company_category ON vulnerabilities_v2_partitioned(company_id, category);
CREATE INDEX idx_vulnerabilities_v2_company_status ON vulnerabilities_v2_partitioned(company_id, status);

-- Network findings indexes
CREATE INDEX idx_network_findings_agent_id ON network_findings_partitioned(agent_id);
CREATE INDEX idx_network_findings_company_id ON network_findings_partitioned(company_id);
CREATE INDEX idx_network_findings_host_port ON network_findings_partitioned(host, port);
CREATE INDEX idx_network_findings_service ON network_findings_partitioned(service_name);
CREATE INDEX idx_network_findings_ssl ON network_findings_partitioned(ssl_enabled);

-- Compliance checks indexes
CREATE INDEX idx_compliance_checks_agent_id ON compliance_checks_partitioned(agent_id);
CREATE INDEX idx_compliance_checks_company_id ON compliance_checks_partitioned(company_id);
CREATE INDEX idx_compliance_checks_framework ON compliance_checks_partitioned(framework);
CREATE INDEX idx_compliance_checks_status ON compliance_checks_partitioned(status);
CREATE INDEX idx_compliance_checks_severity ON compliance_checks_partitioned(severity);

-- System vulnerabilities indexes
CREATE INDEX idx_system_vulnerabilities_agent_id ON system_vulnerabilities(agent_id);
CREATE INDEX idx_system_vulnerabilities_company_id ON system_vulnerabilities(company_id);
CREATE INDEX idx_system_vulnerabilities_type ON system_vulnerabilities(vulnerability_type);
CREATE INDEX idx_system_vulnerabilities_severity ON system_vulnerabilities(severity);
CREATE INDEX idx_system_vulnerabilities_cve ON system_vulnerabilities(cve_id);

-- Auth findings indexes
CREATE INDEX idx_auth_findings_agent_id ON auth_findings(agent_id);
CREATE INDEX idx_auth_findings_company_id ON auth_findings(company_id);
CREATE INDEX idx_auth_findings_type ON auth_findings(finding_type);
CREATE INDEX idx_auth_findings_severity ON auth_findings(severity);

-- Database findings indexes
CREATE INDEX idx_database_findings_agent_id ON database_findings(agent_id);
CREATE INDEX idx_database_findings_company_id ON database_findings(company_id);
CREATE INDEX idx_database_findings_type ON database_findings(database_type);
CREATE INDEX idx_database_findings_severity ON database_findings(severity);

-- API findings indexes
CREATE INDEX idx_api_findings_agent_id ON api_findings(agent_id);
CREATE INDEX idx_api_findings_company_id ON api_findings(company_id);
CREATE INDEX idx_api_findings_type ON api_findings(api_type);
CREATE INDEX idx_api_findings_severity ON api_findings(severity);

-- Container findings indexes
CREATE INDEX idx_container_findings_agent_id ON container_findings(agent_id);
CREATE INDEX idx_container_findings_company_id ON container_findings(company_id);
CREATE INDEX idx_container_findings_image ON container_findings(image_name);
CREATE INDEX idx_container_findings_severity ON container_findings(severity);

-- AI/ML findings indexes
CREATE INDEX idx_ai_ml_findings_agent_id ON ai_ml_findings(agent_id);
CREATE INDEX idx_ai_ml_findings_company_id ON ai_ml_findings(company_id);
CREATE INDEX idx_ai_ml_findings_type ON ai_ml_findings(finding_type);
CREATE INDEX idx_ai_ml_findings_severity ON ai_ml_findings(severity);

-- IoT/OT findings indexes
CREATE INDEX idx_iot_ot_findings_agent_id ON iot_ot_findings(agent_id);
CREATE INDEX idx_iot_ot_findings_company_id ON iot_ot_findings(company_id);
CREATE INDEX idx_iot_ot_findings_type ON iot_ot_findings(device_type);
CREATE INDEX idx_iot_ot_findings_severity ON iot_ot_findings(severity);

-- Privacy findings indexes
CREATE INDEX idx_privacy_findings_agent_id ON privacy_findings(agent_id);
CREATE INDEX idx_privacy_findings_company_id ON privacy_findings(company_id);
CREATE INDEX idx_privacy_findings_type ON privacy_findings(finding_type);
CREATE INDEX idx_privacy_findings_severity ON privacy_findings(severity);

-- Web3 findings indexes
CREATE INDEX idx_web3_findings_agent_id ON web3_findings(agent_id);
CREATE INDEX idx_web3_findings_company_id ON web3_findings(company_id);
CREATE INDEX idx_web3_findings_type ON web3_findings(finding_type);
CREATE INDEX idx_web3_findings_severity ON web3_findings(severity);

-- ============================================================================
-- FULL-TEXT SEARCH INDEXES
-- ============================================================================

-- Full-text search for vulnerabilities v2
CREATE INDEX idx_vulnerabilities_v2_search ON vulnerabilities_v2_partitioned 
    USING gin(to_tsvector('english', title || ' ' || COALESCE(description, '')));

-- Full-text search for network findings
CREATE INDEX idx_network_findings_search ON network_findings_partitioned 
    USING gin(to_tsvector('english', service_name || ' ' || COALESCE(banner, '')));

-- ============================================================================
-- ROW-LEVEL SECURITY
-- ============================================================================

-- Enable RLS on all partitioned tables
ALTER TABLE vulnerabilities_v2_partitioned ENABLE ROW LEVEL SECURITY;
ALTER TABLE network_findings_partitioned ENABLE ROW LEVEL SECURITY;
ALTER TABLE compliance_checks_partitioned ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY vulnerabilities_v2_isolation ON vulnerabilities_v2_partitioned
    FOR ALL USING (company_id = current_setting('app.current_company_id')::UUID);

CREATE POLICY network_findings_isolation ON network_findings_partitioned
    FOR ALL USING (company_id = current_setting('app.current_company_id')::UUID);

CREATE POLICY compliance_checks_isolation ON compliance_checks_partitioned
    FOR ALL USING (company_id = current_setting('app.current_company_id')::UUID);

-- ============================================================================
-- TRIGGERS FOR UPDATED_AT
-- ============================================================================

-- Create trigger function for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply triggers to all tables
CREATE TRIGGER update_vulnerabilities_v2_updated_at BEFORE UPDATE ON vulnerabilities_v2
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_network_findings_updated_at BEFORE UPDATE ON network_findings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_compliance_checks_updated_at BEFORE UPDATE ON compliance_checks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_system_vulnerabilities_updated_at BEFORE UPDATE ON system_vulnerabilities
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_auth_findings_updated_at BEFORE UPDATE ON auth_findings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_database_findings_updated_at BEFORE UPDATE ON database_findings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_api_findings_updated_at BEFORE UPDATE ON api_findings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_container_findings_updated_at BEFORE UPDATE ON container_findings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ai_ml_findings_updated_at BEFORE UPDATE ON ai_ml_findings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_iot_ot_findings_updated_at BEFORE UPDATE ON iot_ot_findings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_privacy_findings_updated_at BEFORE UPDATE ON privacy_findings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_web3_findings_updated_at BEFORE UPDATE ON web3_findings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- VIEWS FOR ANALYTICS
-- ============================================================================

-- Comprehensive vulnerability summary view
CREATE VIEW vulnerability_summary_v2 AS
SELECT 
    v.id,
    v.agent_id,
    v.company_id,
    v.title,
    v.severity,
    v.category,
    v.status,
    v.risk_score,
    v.discovered_at,
    v.last_seen,
    a.hostname,
    a.os,
    a.os_version
FROM vulnerabilities_v2_partitioned v
LEFT JOIN agents a ON v.agent_id = a.id;

-- Compliance framework summary view
CREATE VIEW compliance_summary AS
SELECT 
    c.company_id,
    c.framework,
    COUNT(*) as total_checks,
    COUNT(CASE WHEN c.status = 'pass' THEN 1 END) as passed_checks,
    COUNT(CASE WHEN c.status = 'fail' THEN 1 END) as failed_checks,
    COUNT(CASE WHEN c.status = 'not_applicable' THEN 1 END) as not_applicable_checks,
    ROUND(
        (COUNT(CASE WHEN c.status = 'pass' THEN 1 END)::DECIMAL / 
         NULLIF(COUNT(CASE WHEN c.status IN ('pass', 'fail') THEN 1 END), 0)) * 100, 2
    ) as compliance_score
FROM compliance_checks_partitioned c
GROUP BY c.company_id, c.framework;

-- Network security summary view
CREATE VIEW network_security_summary AS
SELECT 
    n.company_id,
    n.agent_id,
    COUNT(*) as total_findings,
    COUNT(CASE WHEN n.ssl_enabled = false THEN 1 END) as non_ssl_services,
    COUNT(CASE WHEN n.vulnerability_count > 0 THEN 1 END) as vulnerable_services,
    COUNT(DISTINCT n.host) as unique_hosts,
    COUNT(DISTINCT n.port) as unique_ports
FROM network_findings_partitioned n
GROUP BY n.company_id, n.agent_id;

-- ============================================================================
-- FUNCTIONS FOR ANALYTICS
-- ============================================================================

-- Function to get comprehensive security statistics
CREATE OR REPLACE FUNCTION get_security_statistics(
    p_company_id UUID,
    p_date_from TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_date_to TIMESTAMP WITH TIME ZONE DEFAULT NULL
)
RETURNS TABLE (
    total_vulnerabilities BIGINT,
    vulnerabilities_by_category JSONB,
    vulnerabilities_by_severity JSONB,
    compliance_scores JSONB,
    network_findings_count BIGINT,
    system_vulnerabilities_count BIGINT,
    auth_findings_count BIGINT,
    database_findings_count BIGINT,
    api_findings_count BIGINT,
    container_findings_count BIGINT,
    ai_ml_findings_count BIGINT,
    iot_ot_findings_count BIGINT,
    privacy_findings_count BIGINT,
    web3_findings_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        (SELECT COUNT(*) FROM vulnerabilities_v2_partitioned v 
         WHERE v.company_id = p_company_id
         AND (p_date_from IS NULL OR v.discovered_at >= p_date_from)
         AND (p_date_to IS NULL OR v.discovered_at <= p_date_to)) as total_vulnerabilities,
        
        (SELECT jsonb_object_agg(category, count) FROM (
            SELECT category, COUNT(*) as count
            FROM vulnerabilities_v2_partitioned v
            WHERE v.company_id = p_company_id
            AND (p_date_from IS NULL OR v.discovered_at >= p_date_from)
            AND (p_date_to IS NULL OR v.discovered_at <= p_date_to)
            GROUP BY category
        ) t) as vulnerabilities_by_category,
        
        (SELECT jsonb_object_agg(severity, count) FROM (
            SELECT severity, COUNT(*) as count
            FROM vulnerabilities_v2_partitioned v
            WHERE v.company_id = p_company_id
            AND (p_date_from IS NULL OR v.discovered_at >= p_date_from)
            AND (p_date_to IS NULL OR v.discovered_at <= p_date_to)
            GROUP BY severity
        ) t) as vulnerabilities_by_severity,
        
        (SELECT jsonb_object_agg(framework, compliance_score) FROM (
            SELECT framework, 
                   ROUND((COUNT(CASE WHEN status = 'pass' THEN 1 END)::DECIMAL / 
                          NULLIF(COUNT(CASE WHEN status IN ('pass', 'fail') THEN 1 END), 0)) * 100, 2) as compliance_score
            FROM compliance_checks_partitioned c
            WHERE c.company_id = p_company_id
            AND (p_date_from IS NULL OR c.created_at >= p_date_from)
            AND (p_date_to IS NULL OR c.created_at <= p_date_to)
            GROUP BY framework
        ) t) as compliance_scores,
        
        (SELECT COUNT(*) FROM network_findings_partitioned n 
         WHERE n.company_id = p_company_id
         AND (p_date_from IS NULL OR n.created_at >= p_date_from)
         AND (p_date_to IS NULL OR n.created_at <= p_date_to)) as network_findings_count,
        
        (SELECT COUNT(*) FROM system_vulnerabilities s 
         WHERE s.company_id = p_company_id
         AND (p_date_from IS NULL OR s.created_at >= p_date_from)
         AND (p_date_to IS NULL OR s.created_at <= p_date_to)) as system_vulnerabilities_count,
        
        (SELECT COUNT(*) FROM auth_findings a 
         WHERE a.company_id = p_company_id
         AND (p_date_from IS NULL OR a.created_at >= p_date_from)
         AND (p_date_to IS NULL OR a.created_at <= p_date_to)) as auth_findings_count,
        
        (SELECT COUNT(*) FROM database_findings d 
         WHERE d.company_id = p_company_id
         AND (p_date_from IS NULL OR d.created_at >= p_date_from)
         AND (p_date_to IS NULL OR d.created_at <= p_date_to)) as database_findings_count,
        
        (SELECT COUNT(*) FROM api_findings a 
         WHERE a.company_id = p_company_id
         AND (p_date_from IS NULL OR a.created_at >= p_date_from)
         AND (p_date_to IS NULL OR a.created_at <= p_date_to)) as api_findings_count,
        
        (SELECT COUNT(*) FROM container_findings c 
         WHERE c.company_id = p_company_id
         AND (p_date_from IS NULL OR c.created_at >= p_date_from)
         AND (p_date_to IS NULL OR c.created_at <= p_date_to)) as container_findings_count,
        
        (SELECT COUNT(*) FROM ai_ml_findings a 
         WHERE a.company_id = p_company_id
         AND (p_date_from IS NULL OR a.created_at >= p_date_from)
         AND (p_date_to IS NULL OR a.created_at <= p_date_to)) as ai_ml_findings_count,
        
        (SELECT COUNT(*) FROM iot_ot_findings i 
         WHERE i.company_id = p_company_id
         AND (p_date_from IS NULL OR i.created_at >= p_date_from)
         AND (p_date_to IS NULL OR i.created_at <= p_date_to)) as iot_ot_findings_count,
        
        (SELECT COUNT(*) FROM privacy_findings p 
         WHERE p.company_id = p_company_id
         AND (p_date_from IS NULL OR p.created_at >= p_date_from)
         AND (p_date_to IS NULL OR p.created_at <= p_date_to)) as privacy_findings_count,
        
        (SELECT COUNT(*) FROM web3_findings w 
         WHERE w.company_id = p_company_id
         AND (p_date_from IS NULL OR w.created_at >= p_date_from)
         AND (p_date_to IS NULL OR w.created_at <= p_date_to)) as web3_findings_count;
END;
$$ LANGUAGE plpgsql;

-- Function to get risk heatmap data
CREATE OR REPLACE FUNCTION get_risk_heatmap_data(
    p_company_id UUID,
    p_date_from TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_date_to TIMESTAMP WITH TIME ZONE DEFAULT NULL
)
RETURNS TABLE (
    category VARCHAR(50),
    severity VARCHAR(20),
    count BIGINT,
    risk_score DECIMAL(3,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        v.category,
        v.severity,
        COUNT(*) as count,
        AVG(v.risk_score) as risk_score
    FROM vulnerabilities_v2_partitioned v
    WHERE v.company_id = p_company_id
    AND (p_date_from IS NULL OR v.discovered_at >= p_date_from)
    AND (p_date_to IS NULL OR v.discovered_at <= p_date_to)
    GROUP BY v.category, v.severity
    ORDER BY v.category, v.severity;
END;
$$ LANGUAGE plpgsql;

COMMIT;
