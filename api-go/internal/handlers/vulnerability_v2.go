package handlers

import (
	"fmt"
	"net/http"
	"strings"
	"time"

	"zerotrace/api/internal/models"
	"zerotrace/api/internal/services"
	"zerotrace/api/internal/types"

	"github.com/gin-gonic/gin"
)

// VulnerabilityV2Handler handles API v2 vulnerability endpoints
type VulnerabilityV2Handler struct {
	vulnerabilityService *services.VulnerabilityV2Service
	agentService         *services.AgentService
}

// NewVulnerabilityV2Handler creates a new vulnerability v2 handler
func NewVulnerabilityV2Handler(vs *services.VulnerabilityV2Service, as *services.AgentService) *VulnerabilityV2Handler {
	return &VulnerabilityV2Handler{
		vulnerabilityService: vs,
		agentService:         as,
	}
}

// GetVulnerabilitiesV2 retrieves vulnerabilities with enhanced filtering
func (h *VulnerabilityV2Handler) GetVulnerabilitiesV2(c *gin.Context) {
	var req types.VulnerabilityV2Request
	if err := c.ShouldBindQuery(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Set defaults
	if req.Page <= 0 {
		req.Page = 1
	}
	if req.PageSize <= 0 {
		req.PageSize = 20
	}
	if req.SortBy == "" {
		req.SortBy = "severity"
	}
	if req.SortOrder == "" {
		req.SortOrder = "desc"
	}

	// Get vulnerabilities
	vulnerabilities, total, err := h.vulnerabilityService.GetVulnerabilitiesV2(req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Calculate statistics
	categories := make(map[string]int)
	severities := make(map[string]int)
	compliance := make(map[string]int)
	riskScores := make(map[string]int)

	for _, vuln := range vulnerabilities {
		categories[vuln.Category]++
		severities[vuln.Severity]++
		for _, framework := range vuln.ComplianceFrameworks {
			compliance[framework]++
		}
		riskScoreRange := h.getRiskScoreRange(vuln.RiskScore)
		riskScores[riskScoreRange]++
	}

	// Calculate total pages
	totalPages := (total + req.PageSize - 1) / req.PageSize

	response := types.VulnerabilityV2Response{
		Vulnerabilities: vulnerabilities,
		Total:           total,
		Page:            req.Page,
		PageSize:        req.PageSize,
		TotalPages:      totalPages,
		Categories:      categories,
		Severities:      severities,
		Compliance:      compliance,
		RiskScores:      riskScores,
		Metadata: map[string]interface{}{
			"scan_time":       time.Now(),
			"filters_applied": h.getAppliedFilters(req),
		},
	}

	c.JSON(http.StatusOK, response)
}

// GetVulnerabilityStats retrieves vulnerability statistics
func (h *VulnerabilityV2Handler) GetVulnerabilityStats(c *gin.Context) {
	stats, err := h.vulnerabilityService.GetVulnerabilityStats()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	response := types.VulnerabilityStatsResponse{
		Total:              stats.Total,
		ByCategory:         stats.ByCategory,
		BySeverity:         stats.BySeverity,
		ByCompliance:       stats.ByCompliance,
		ByRiskScore:        stats.ByRiskScore,
		Trends:             convertTrendsToTypes(stats.Trends),
		TopVulnerabilities: convertTopVulnerabilitiesToTypes(stats.TopVulnerabilities),
		ComplianceScore:    stats.ComplianceScore,
		RiskScore:          stats.RiskScore,
		LastUpdated:        stats.LastUpdated,
	}

	c.JSON(http.StatusOK, response)
}

// GetComplianceStatus retrieves compliance status
func (h *VulnerabilityV2Handler) GetComplianceStatus(c *gin.Context) {
	status, err := h.vulnerabilityService.GetComplianceStatus()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	response := types.ComplianceStatusResponse{
		OverallScore:    status.OverallScore,
		Frameworks:      convertFrameworkScoresToTypes(status.Frameworks),
		GapAnalysis:     convertGapAnalysisToTypes(status.GapAnalysis),
		Recommendations: status.Recommendations,
		LastAudit:       status.LastAudit,
		NextAudit:       status.NextAudit,
	}

	c.JSON(http.StatusOK, response)
}

// ExportVulnerabilities exports vulnerabilities in various formats
func (h *VulnerabilityV2Handler) ExportVulnerabilities(c *gin.Context) {
	var req types.VulnerabilityV2Request
	if err := c.ShouldBindQuery(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Set default export format
	if req.Export == "" {
		req.Export = "json"
	}

	// Get vulnerabilities
	vulnerabilities, _, err := h.vulnerabilityService.GetVulnerabilitiesV2(req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Convert vulnerabilities to models for export
	vulnModels := convertVulnerabilitiesToModels(vulnerabilities)

	// Export based on format
	switch strings.ToLower(req.Export) {
	case "json":
		h.exportJSON(c, vulnModels)
	case "csv":
		h.exportCSV(c, vulnModels)
	case "pdf":
		h.exportPDF(c, vulnModels)
	case "sarif":
		h.exportSARIF(c, vulnModels)
	default:
		c.JSON(http.StatusBadRequest, gin.H{"error": "Unsupported export format"})
	}
}

// InitiateNetworkScan initiates a network scan
func (h *VulnerabilityV2Handler) InitiateNetworkScan(c *gin.Context) {
	var req struct {
		AgentID     string   `json:"agent_id"`
		Targets     []string `json:"targets"`
		Ports       []int    `json:"ports"`
		ScanType    string   `json:"scan_type"` // tcp, udp, syn, full
		Timeout     int      `json:"timeout"`
		Concurrency int      `json:"concurrency"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Set defaults
	if req.ScanType == "" {
		req.ScanType = "tcp"
	}
	if req.Timeout <= 0 {
		req.Timeout = 30
	}
	if req.Concurrency <= 0 {
		req.Concurrency = 10
	}

	// Initiate scan
	scanID, err := h.vulnerabilityService.InitiateNetworkScan(req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"scan_id":    scanID,
		"status":     "initiated",
		"message":    "Network scan initiated successfully",
		"created_at": time.Now(),
	})
}

// GetScanStatus retrieves scan status
func (h *VulnerabilityV2Handler) GetScanStatus(c *gin.Context) {
	scanID := c.Param("scan_id")
	if scanID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Scan ID is required"})
		return
	}

	status, err := h.vulnerabilityService.GetScanStatus(scanID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, status)
}

// GetScanResults retrieves scan results
func (h *VulnerabilityV2Handler) GetScanResults(c *gin.Context) {
	scanID := c.Param("scan_id")
	if scanID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Scan ID is required"})
		return
	}

	results, err := h.vulnerabilityService.GetScanResults(scanID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, results)
}

// Helper functions

// getRiskScoreRange returns the risk score range
func (h *VulnerabilityV2Handler) getRiskScoreRange(score float64) string {
	switch {
	case score >= 0.9:
		return "critical"
	case score >= 0.7:
		return "high"
	case score >= 0.5:
		return "medium"
	case score >= 0.3:
		return "low"
	default:
		return "info"
	}
}

// getAppliedFilters returns applied filters
func (h *VulnerabilityV2Handler) getAppliedFilters(req types.VulnerabilityV2Request) map[string]interface{} {
	filters := make(map[string]interface{})

	if req.Category != "" {
		filters["category"] = req.Category
	}
	if req.Severity != "" {
		filters["severity"] = req.Severity
	}
	if req.Compliance != "" {
		filters["compliance"] = req.Compliance
	}
	if req.AgentID != "" {
		filters["agent_id"] = req.AgentID
	}
	if req.Search != "" {
		filters["search"] = req.Search
	}
	if req.Status != "" {
		filters["status"] = req.Status
	}
	if req.DateFrom != "" {
		filters["date_from"] = req.DateFrom
	}
	if req.DateTo != "" {
		filters["date_to"] = req.DateTo
	}
	if len(req.Tags) > 0 {
		filters["tags"] = req.Tags
	}

	return filters
}

// exportJSON exports vulnerabilities as JSON
func (h *VulnerabilityV2Handler) exportJSON(c *gin.Context, vulnerabilities []models.VulnerabilityV2) {
	c.Header("Content-Type", "application/json")
	c.Header("Content-Disposition", "attachment; filename=vulnerabilities.json")
	c.JSON(http.StatusOK, vulnerabilities)
}

// exportCSV exports vulnerabilities as CSV
func (h *VulnerabilityV2Handler) exportCSV(c *gin.Context, vulnerabilities []models.VulnerabilityV2) {
	c.Header("Content-Type", "text/csv")
	c.Header("Content-Disposition", "attachment; filename=vulnerabilities.csv")

	// CSV header
	csv := "ID,Title,Severity,Category,Status,Discovered,Agent,Risk Score,Description\n"

	// CSV data
	for _, vuln := range vulnerabilities {
		csv += fmt.Sprintf("%s,%s,%s,%s,%s,%s,%s,%.2f,%s\n",
			vuln.ID,
			vuln.Title,
			vuln.Severity,
			vuln.Category,
			vuln.Status,
			vuln.DiscoveredAt.Format("2006-01-02 15:04:05"),
			vuln.AgentID,
			vuln.RiskScore,
			vuln.Description,
		)
	}

	c.String(http.StatusOK, csv)
}

// exportPDF exports vulnerabilities as PDF
func (h *VulnerabilityV2Handler) exportPDF(c *gin.Context, vulnerabilities []models.VulnerabilityV2) {
	// This would generate a PDF report
	// For now, return a placeholder
	c.JSON(http.StatusNotImplemented, gin.H{"error": "PDF export not implemented yet"})
}

// exportSARIF exports vulnerabilities as SARIF
func (h *VulnerabilityV2Handler) exportSARIF(c *gin.Context, vulnerabilities []models.VulnerabilityV2) {
	c.Header("Content-Type", "application/json")
	c.Header("Content-Disposition", "attachment; filename=vulnerabilities.sarif")

	// SARIF format
	sarif := map[string]interface{}{
		"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
		"version": "2.1.0",
		"runs": []map[string]interface{}{
			{
				"tool": map[string]interface{}{
					"driver": map[string]interface{}{
						"name":    "ZeroTrace",
						"version": "2.0.0",
					},
				},
				"results": h.convertToSARIFResults(vulnerabilities),
			},
		},
	}

	c.JSON(http.StatusOK, sarif)
}

// convertToSARIFResults converts vulnerabilities to SARIF results
func (h *VulnerabilityV2Handler) convertToSARIFResults(vulnerabilities []models.VulnerabilityV2) []map[string]interface{} {
	var results []map[string]interface{}

	for _, vuln := range vulnerabilities {
		result := map[string]interface{}{
			"ruleId": vuln.ID,
			"level":  h.getSARIFLevel(vuln.Severity),
			"message": map[string]interface{}{
				"text": vuln.Description,
			},
			"locations": []map[string]interface{}{
				{
					"physicalLocation": map[string]interface{}{
						"artifactLocation": map[string]interface{}{
							"uri": vuln.AgentID,
						},
					},
				},
			},
			"properties": map[string]interface{}{
				"category":   vuln.Category,
				"risk_score": vuln.RiskScore,
				"status":     vuln.Status,
				"discovered": vuln.DiscoveredAt,
			},
		}
		results = append(results, result)
	}

	return results
}

// getSARIFLevel returns SARIF level
func (h *VulnerabilityV2Handler) getSARIFLevel(severity string) string {
	switch severity {
	case "critical":
		return "error"
	case "high":
		return "error"
	case "medium":
		return "warning"
	case "low":
		return "note"
	default:
		return "note"
	}
}

// Conversion functions to convert models to types
func convertTrendsToTypes(trends []models.TrendData) []types.TrendData {
	var result []types.TrendData
	for _, trend := range trends {
		result = append(result, types.TrendData{
			Date:  trend.Date,
			Count: trend.Count,
		})
	}
	return result
}

func convertTopVulnerabilitiesToTypes(topVulns []models.TopVulnerability) []types.TopVulnerability {
	var result []types.TopVulnerability
	for _, vuln := range topVulns {
		result = append(result, types.TopVulnerability{
			ID:        vuln.ID,
			Title:     vuln.Title,
			Severity:  vuln.Severity,
			Count:     vuln.Count,
			RiskScore: vuln.RiskScore,
		})
	}
	return result
}

func convertFrameworkScoresToTypes(frameworks map[string]models.FrameworkScore) map[string]types.FrameworkScore {
	result := make(map[string]types.FrameworkScore)
	for name, score := range frameworks {
		result[name] = types.FrameworkScore{
			Score:        score.Score,
			TotalChecks:  score.TotalChecks,
			PassedChecks: score.PassedChecks,
			FailedChecks: score.FailedChecks,
			Status:       score.Status,
		}
	}
	return result
}

func convertGapAnalysisToTypes(gaps []models.GapAnalysis) []types.GapAnalysis {
	var result []types.GapAnalysis
	for _, gap := range gaps {
		result = append(result, types.GapAnalysis{
			Framework:   gap.Framework,
			Requirement: gap.Requirement,
			Status:      gap.Status,
			Gap:         gap.Gap,
			Remediation: gap.Remediation,
			Priority:    gap.Priority,
		})
	}
	return result
}

func convertVulnerabilitiesToModels(vulnerabilities []types.VulnerabilityV2Data) []models.VulnerabilityV2 {
	var result []models.VulnerabilityV2
	for _, vuln := range vulnerabilities {
		result = append(result, models.VulnerabilityV2{
			ID:                   vuln.ID,
			AgentID:              vuln.AgentID,
			Title:                vuln.Title,
			Description:          vuln.Description,
			Severity:             vuln.Severity,
			Category:             vuln.Category,
			Status:               vuln.Status,
			DiscoveredAt:         vuln.DiscoveredAt,
			LastSeen:             vuln.LastSeen,
			RiskScore:            vuln.RiskScore,
			ExploitComplexity:    vuln.ExploitComplexity,
			AttackVector:         vuln.AttackVector,
			ComplianceFrameworks: vuln.ComplianceFrameworks,
			Remediation:          vuln.Remediation,
			References:           vuln.References,
			Tags:                 vuln.Tags,
			Metadata:             vuln.Metadata,
			EnrichmentData:       vuln.EnrichmentData,
			CreatedAt:            vuln.CreatedAt,
			UpdatedAt:            vuln.UpdatedAt,
		})
	}
	return result
}
