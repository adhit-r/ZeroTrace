package services

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"zerotrace/api/internal/models"
	"zerotrace/api/internal/types"

	"github.com/google/uuid"
)

// VulnerabilityV2Service handles enhanced vulnerability operations
type VulnerabilityV2Service struct {
	// This would typically include database connections, cache, etc.
	// For now, we'll use in-memory storage
	vulnerabilities   map[string]models.VulnerabilityV2
	networkFindings   map[string]models.NetworkFinding
	complianceChecks  map[string]models.ComplianceCheck
	systemVulns       map[string]models.SystemVulnerability
	authFindings      map[string]models.AuthFinding
	dbFindings        map[string]models.DatabaseFinding
	apiFindings       map[string]models.APIFinding
	containerFindings map[string]models.ContainerFinding
	aiMLFindings      map[string]models.AIMLFinding
	iotOTFindings     map[string]models.IoTOTFinding
	privacyFindings   map[string]models.PrivacyFinding
	web3Findings      map[string]models.Web3Finding
	scanResults       map[string]models.ScanResult
}

// NewVulnerabilityV2Service creates a new vulnerability v2 service
func NewVulnerabilityV2Service() *VulnerabilityV2Service {
	return &VulnerabilityV2Service{
		vulnerabilities:   make(map[string]models.VulnerabilityV2),
		networkFindings:   make(map[string]models.NetworkFinding),
		complianceChecks:  make(map[string]models.ComplianceCheck),
		systemVulns:       make(map[string]models.SystemVulnerability),
		authFindings:      make(map[string]models.AuthFinding),
		dbFindings:        make(map[string]models.DatabaseFinding),
		apiFindings:       make(map[string]models.APIFinding),
		containerFindings: make(map[string]models.ContainerFinding),
		aiMLFindings:      make(map[string]models.AIMLFinding),
		iotOTFindings:     make(map[string]models.IoTOTFinding),
		privacyFindings:   make(map[string]models.PrivacyFinding),
		web3Findings:      make(map[string]models.Web3Finding),
		scanResults:       make(map[string]models.ScanResult),
	}
}

// GetVulnerabilitiesV2 retrieves vulnerabilities with enhanced filtering
func (vs *VulnerabilityV2Service) GetVulnerabilitiesV2(req types.VulnerabilityV2Request) ([]types.VulnerabilityV2Data, int, error) {
	var vulnerabilities []models.VulnerabilityV2

	// Collect all vulnerabilities from different sources
	allVulns := make([]models.VulnerabilityV2, 0)

	// Add network findings
	for _, finding := range vs.networkFindings {
		vuln := models.VulnerabilityV2{
			ID:                   finding.ID,
			AgentID:              finding.AgentID,
			Title:                finding.Description,
			Description:          finding.Description,
			Severity:             finding.Severity,
			Category:             "network",
			Status:               finding.Status,
			DiscoveredAt:         finding.DiscoveredAt,
			LastSeen:             finding.DiscoveredAt,
			RiskScore:            vs.calculateRiskScore(finding.Severity),
			ExploitComplexity:    "medium",
			AttackVector:         "network",
			ComplianceFrameworks: []string{},
			Remediation:          finding.Remediation,
			References:           []string{},
			Tags:                 []string{"network", finding.Protocol},
			Metadata:             finding.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            finding.CreatedAt,
			UpdatedAt:            finding.UpdatedAt,
		}
		allVulns = append(allVulns, vuln)
	}

	// Add compliance checks
	for _, check := range vs.complianceChecks {
		vuln := models.VulnerabilityV2{
			ID:                   check.ID,
			AgentID:              check.AgentID,
			Title:                check.CheckName,
			Description:          check.Description,
			Severity:             check.Severity,
			Category:             "configuration",
			Status:               check.Status,
			DiscoveredAt:         check.CheckedAt,
			LastSeen:             check.CheckedAt,
			RiskScore:            vs.calculateRiskScore(check.Severity),
			ExploitComplexity:    "low",
			AttackVector:         "configuration",
			ComplianceFrameworks: []string{check.Framework},
			Remediation:          check.Remediation,
			References:           []string{},
			Tags:                 []string{"compliance", check.Framework, check.Category},
			Metadata:             check.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            check.CreatedAt,
			UpdatedAt:            check.UpdatedAt,
		}
		allVulns = append(allVulns, vuln)
	}

	// Add system vulnerabilities
	for _, vuln := range vs.systemVulns {
		vulnV2 := models.VulnerabilityV2{
			ID:                   vuln.ID,
			AgentID:              vuln.AgentID,
			Title:                vuln.Title,
			Description:          vuln.Description,
			Severity:             vuln.Severity,
			Category:             "system",
			Status:               vuln.Status,
			DiscoveredAt:         vuln.DiscoveredAt,
			LastSeen:             vuln.DiscoveredAt,
			RiskScore:            vs.calculateRiskScore(vuln.Severity),
			ExploitComplexity:    "medium",
			AttackVector:         "local",
			ComplianceFrameworks: []string{},
			Remediation:          vuln.Remediation,
			References:           []string{},
			Tags:                 []string{"system", vuln.OS, vuln.VulnType},
			Metadata:             vuln.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            vuln.CreatedAt,
			UpdatedAt:            vuln.UpdatedAt,
		}
		allVulns = append(allVulns, vulnV2)
	}

	// Add auth findings
	for _, finding := range vs.authFindings {
		vuln := models.VulnerabilityV2{
			ID:                   finding.ID,
			AgentID:              finding.AgentID,
			Title:                finding.Title,
			Description:          finding.Description,
			Severity:             finding.Severity,
			Category:             "authentication",
			Status:               finding.Status,
			DiscoveredAt:         finding.DiscoveredAt,
			LastSeen:             finding.DiscoveredAt,
			RiskScore:            vs.calculateRiskScore(finding.Severity),
			ExploitComplexity:    "low",
			AttackVector:         "local",
			ComplianceFrameworks: []string{},
			Remediation:          finding.Remediation,
			References:           []string{},
			Tags:                 []string{"auth", finding.FindingType, finding.AccountType},
			Metadata:             finding.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            finding.CreatedAt,
			UpdatedAt:            finding.UpdatedAt,
		}
		allVulns = append(allVulns, vuln)
	}

	// Add database findings
	for _, finding := range vs.dbFindings {
		vuln := models.VulnerabilityV2{
			ID:                   finding.ID,
			AgentID:              finding.AgentID,
			Title:                finding.Title,
			Description:          finding.Description,
			Severity:             finding.Severity,
			Category:             "database",
			Status:               finding.Status,
			DiscoveredAt:         finding.DiscoveredAt,
			LastSeen:             finding.DiscoveredAt,
			RiskScore:            vs.calculateRiskScore(finding.Severity),
			ExploitComplexity:    "medium",
			AttackVector:         "network",
			ComplianceFrameworks: []string{},
			Remediation:          finding.Remediation,
			References:           []string{},
			Tags:                 []string{"database", finding.DatabaseType, finding.FindingType},
			Metadata:             finding.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            finding.CreatedAt,
			UpdatedAt:            finding.UpdatedAt,
		}
		allVulns = append(allVulns, vuln)
	}

	// Add API findings
	for _, finding := range vs.apiFindings {
		vuln := models.VulnerabilityV2{
			ID:                   finding.ID,
			AgentID:              finding.AgentID,
			Title:                finding.Title,
			Description:          finding.Description,
			Severity:             finding.Severity,
			Category:             "api",
			Status:               finding.Status,
			DiscoveredAt:         finding.DiscoveredAt,
			LastSeen:             finding.DiscoveredAt,
			RiskScore:            vs.calculateRiskScore(finding.Severity),
			ExploitComplexity:    "medium",
			AttackVector:         "network",
			ComplianceFrameworks: []string{},
			Remediation:          finding.Remediation,
			References:           []string{},
			Tags:                 []string{"api", finding.FindingType, finding.Method},
			Metadata:             finding.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            finding.CreatedAt,
			UpdatedAt:            finding.UpdatedAt,
		}
		allVulns = append(allVulns, vuln)
	}

	// Add container findings
	for _, finding := range vs.containerFindings {
		vuln := models.VulnerabilityV2{
			ID:                   finding.ID,
			AgentID:              finding.AgentID,
			Title:                finding.Title,
			Description:          finding.Description,
			Severity:             finding.Severity,
			Category:             "container",
			Status:               finding.Status,
			DiscoveredAt:         finding.DiscoveredAt,
			LastSeen:             finding.DiscoveredAt,
			RiskScore:            vs.calculateRiskScore(finding.Severity),
			ExploitComplexity:    "high",
			AttackVector:         "local",
			ComplianceFrameworks: []string{},
			Remediation:          finding.Remediation,
			References:           []string{},
			Tags:                 []string{"container", finding.FindingType, finding.ImageName},
			Metadata:             finding.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            finding.CreatedAt,
			UpdatedAt:            finding.UpdatedAt,
		}
		allVulns = append(allVulns, vuln)
	}

	// Add AI/ML findings
	for _, finding := range vs.aiMLFindings {
		vuln := models.VulnerabilityV2{
			ID:                   finding.ID,
			AgentID:              finding.AgentID,
			Title:                finding.Title,
			Description:          finding.Description,
			Severity:             finding.Severity,
			Category:             "ai",
			Status:               finding.Status,
			DiscoveredAt:         finding.DiscoveredAt,
			LastSeen:             finding.DiscoveredAt,
			RiskScore:            vs.calculateRiskScore(finding.Severity),
			ExploitComplexity:    "high",
			AttackVector:         "network",
			ComplianceFrameworks: []string{},
			Remediation:          finding.Remediation,
			References:           []string{},
			Tags:                 []string{"ai", finding.FindingType, finding.Framework},
			Metadata:             finding.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            finding.CreatedAt,
			UpdatedAt:            finding.UpdatedAt,
		}
		allVulns = append(allVulns, vuln)
	}

	// Add IoT/OT findings
	for _, finding := range vs.iotOTFindings {
		vuln := models.VulnerabilityV2{
			ID:                   finding.ID,
			AgentID:              finding.AgentID,
			Title:                finding.Title,
			Description:          finding.Description,
			Severity:             finding.Severity,
			Category:             "iot",
			Status:               finding.Status,
			DiscoveredAt:         finding.DiscoveredAt,
			LastSeen:             finding.DiscoveredAt,
			RiskScore:            vs.calculateRiskScore(finding.Severity),
			ExploitComplexity:    "medium",
			AttackVector:         "network",
			ComplianceFrameworks: []string{},
			Remediation:          finding.Remediation,
			References:           []string{},
			Tags:                 []string{"iot", finding.FindingType, finding.DeviceType},
			Metadata:             finding.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            finding.CreatedAt,
			UpdatedAt:            finding.UpdatedAt,
		}
		allVulns = append(allVulns, vuln)
	}

	// Add privacy findings
	for _, finding := range vs.privacyFindings {
		vuln := models.VulnerabilityV2{
			ID:                   finding.ID,
			AgentID:              finding.AgentID,
			Title:                finding.Title,
			Description:          finding.Description,
			Severity:             finding.Severity,
			Category:             "privacy",
			Status:               finding.Status,
			DiscoveredAt:         finding.DiscoveredAt,
			LastSeen:             finding.DiscoveredAt,
			RiskScore:            vs.calculateRiskScore(finding.Severity),
			ExploitComplexity:    "low",
			AttackVector:         "local",
			ComplianceFrameworks: []string{finding.ComplianceFramework},
			Remediation:          finding.Remediation,
			References:           []string{},
			Tags:                 []string{"privacy", finding.FindingType, finding.DataType},
			Metadata:             finding.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            finding.CreatedAt,
			UpdatedAt:            finding.UpdatedAt,
		}
		allVulns = append(allVulns, vuln)
	}

	// Add Web3 findings
	for _, finding := range vs.web3Findings {
		vuln := models.VulnerabilityV2{
			ID:                   finding.ID,
			AgentID:              finding.AgentID,
			Title:                finding.Title,
			Description:          finding.Description,
			Severity:             finding.Severity,
			Category:             "web3",
			Status:               finding.Status,
			DiscoveredAt:         finding.DiscoveredAt,
			LastSeen:             finding.DiscoveredAt,
			RiskScore:            vs.calculateRiskScore(finding.Severity),
			ExploitComplexity:    "high",
			AttackVector:         "network",
			ComplianceFrameworks: []string{},
			Remediation:          finding.Remediation,
			References:           []string{},
			Tags:                 []string{"web3", finding.FindingType, finding.Network},
			Metadata:             finding.Metadata,
			EnrichmentData:       make(map[string]interface{}),
			CreatedAt:            finding.CreatedAt,
			UpdatedAt:            finding.UpdatedAt,
		}
		allVulns = append(allVulns, vuln)
	}

	// Apply filters
	vulnerabilities = vs.filterVulnerabilities(allVulns, req)

	// Sort vulnerabilities
	vulnerabilities = vs.sortVulnerabilities(vulnerabilities, req.SortBy, req.SortOrder)

	// Apply pagination
	total := len(vulnerabilities)
	start := (req.Page - 1) * req.PageSize
	end := start + req.PageSize

	if start >= len(vulnerabilities) {
		vulnerabilities = []models.VulnerabilityV2{}
	} else if end > len(vulnerabilities) {
		vulnerabilities = vulnerabilities[start:]
	} else {
		vulnerabilities = vulnerabilities[start:end]
	}

	// Convert to types
	var result []types.VulnerabilityV2Data
	for _, vuln := range vulnerabilities {
		result = append(result, types.VulnerabilityV2Data{
			ID:                   vuln.ID,
			AgentID:              vuln.AgentID,
			Title:                vuln.Title,
			Description:          vuln.Description,
			Severity:             vuln.Severity,
			Category:             vuln.Category,
			Status:               vuln.Status,
			DiscoveredAt:         vuln.DiscoveredAt,
			LastSeen:             vuln.LastSeen,
			RiskScore:            vuln.RiskScore,
			ExploitComplexity:    vuln.ExploitComplexity,
			AttackVector:         vuln.AttackVector,
			ComplianceFrameworks: vuln.ComplianceFrameworks,
			Remediation:          vuln.Remediation,
			References:           vuln.References,
			Tags:                 vuln.Tags,
			Metadata:             vuln.Metadata,
			EnrichmentData:       vuln.EnrichmentData,
			CreatedAt:            vuln.CreatedAt,
			UpdatedAt:            vuln.UpdatedAt,
		})
	}

	return result, total, nil
}

// GetVulnerabilityStats retrieves vulnerability statistics
func (vs *VulnerabilityV2Service) GetVulnerabilityStats() (models.VulnerabilityStats, error) {
	stats := models.VulnerabilityStats{
		Total:              0,
		ByCategory:         make(map[string]int),
		BySeverity:         make(map[string]int),
		ByCompliance:       make(map[string]int),
		ByRiskScore:        make(map[string]int),
		Trends:             []models.TrendData{},
		TopVulnerabilities: []models.TopVulnerability{},
		ComplianceScore:    0.0,
		RiskScore:          0.0,
		LastUpdated:        time.Now(),
	}

	// Calculate real statistics from agent data
	// This would typically query the database, but for now we'll use agent metadata
	// TODO: Implement proper database queries for historical data

	// For now, return empty stats that will be populated by real data
	stats.Total = 0
	stats.ComplianceScore = 0.0
	stats.RiskScore = 0.0

	return stats, nil
}

// GetComplianceStatus retrieves compliance status
func (vs *VulnerabilityV2Service) GetComplianceStatus() (models.ComplianceStatus, error) {
	status := models.ComplianceStatus{
		OverallScore:    0.75,
		Frameworks:      make(map[string]models.FrameworkScore),
		GapAnalysis:     []models.GapAnalysis{},
		Recommendations: []string{},
		LastAudit:       time.Now().AddDate(0, -1, 0),
		NextAudit:       time.Now().AddDate(0, 1, 0),
	}

	// Add framework scores
	status.Frameworks["CIS"] = models.FrameworkScore{
		Score:        0.80,
		TotalChecks:  100,
		PassedChecks: 80,
		FailedChecks: 20,
		Status:       "partial",
	}

	status.Frameworks["PCI-DSS"] = models.FrameworkScore{
		Score:        0.70,
		TotalChecks:  50,
		PassedChecks: 35,
		FailedChecks: 15,
		Status:       "partial",
	}

	status.Frameworks["HIPAA"] = models.FrameworkScore{
		Score:        0.60,
		TotalChecks:  30,
		PassedChecks: 18,
		FailedChecks: 12,
		Status:       "non_compliant",
	}

	status.Frameworks["GDPR"] = models.FrameworkScore{
		Score:        0.85,
		TotalChecks:  40,
		PassedChecks: 34,
		FailedChecks: 6,
		Status:       "compliant",
	}

	// Add gap analysis
	status.GapAnalysis = []models.GapAnalysis{
		{
			Framework:   "CIS",
			Requirement: "Password Policy",
			Status:      "failed",
			Gap:         "Password policy not enforced",
			Remediation: "Implement strong password policy",
			Priority:    "high",
		},
		{
			Framework:   "PCI-DSS",
			Requirement: "Network Segmentation",
			Status:      "failed",
			Gap:         "Network segmentation not implemented",
			Remediation: "Implement network segmentation",
			Priority:    "critical",
		},
	}

	// Add recommendations
	status.Recommendations = []string{
		"Implement strong password policies",
		"Enable network segmentation",
		"Deploy endpoint protection",
		"Implement data encryption",
		"Conduct regular security training",
	}

	return status, nil
}

// InitiateNetworkScan initiates a network scan
func (vs *VulnerabilityV2Service) InitiateNetworkScan(req struct {
	AgentID     string   `json:"agent_id"`
	Targets     []string `json:"targets"`
	Ports       []int    `json:"ports"`
	ScanType    string   `json:"scan_type"`
	Timeout     int      `json:"timeout"`
	Concurrency int      `json:"concurrency"`
}) (string, error) {
	// Generate scan ID
	scanID := fmt.Sprintf("scan_%d", time.Now().Unix())

	// Create scan result
	scanResult := models.ScanResult{
		ID:              uuid.MustParse(scanID),
		AgentID:         uuid.MustParse(req.AgentID),
		ScanType:        "network",
		Status:          "running",
		Results:         make(map[string]interface{}),
		Vulnerabilities: []models.Vulnerability{},
		Assets:          []models.Asset{},
		Metadata:        make(map[string]interface{}),
		CreatedAt:       time.Now(),
		UpdatedAt:       time.Now(),
	}

	// Store scan result
	vs.scanResults[scanID] = scanResult

	return scanID, nil
}

// GetScanStatus retrieves scan status
func (vs *VulnerabilityV2Service) GetScanStatus(scanID string) (map[string]interface{}, error) {
	scanResult, exists := vs.scanResults[scanID]
	if !exists {
		return nil, fmt.Errorf("scan not found")
	}

	status := map[string]interface{}{
		"scan_id":    scanResult.ID,
		"status":     scanResult.Status,
		"scan_type":  scanResult.ScanType,
		"created_at": scanResult.CreatedAt,
		"updated_at": scanResult.UpdatedAt,
		"findings":   len(scanResult.Vulnerabilities),
		"metadata":   scanResult.Metadata,
	}

	return status, nil
}

// GetScanResults retrieves scan results
func (vs *VulnerabilityV2Service) GetScanResults(scanID string) (map[string]interface{}, error) {
	scanResult, exists := vs.scanResults[scanID]
	if !exists {
		return nil, fmt.Errorf("scan not found")
	}

	results := map[string]interface{}{
		"scan_id":         scanResult.ID,
		"status":          scanResult.Status,
		"scan_type":       scanResult.ScanType,
		"created_at":      scanResult.CreatedAt,
		"updated_at":      scanResult.UpdatedAt,
		"total_findings":  len(scanResult.Vulnerabilities),
		"vulnerabilities": scanResult.Vulnerabilities,
		"assets":          scanResult.Assets,
		"results":         scanResult.Results,
		"metadata":        scanResult.Metadata,
	}

	return results, nil
}

// Helper functions

// calculateRiskScore calculates risk score based on severity
func (vs *VulnerabilityV2Service) calculateRiskScore(severity string) float64 {
	switch severity {
	case "critical":
		return 0.9
	case "high":
		return 0.7
	case "medium":
		return 0.5
	case "low":
		return 0.3
	case "info":
		return 0.1
	default:
		return 0.5
	}
}

// filterVulnerabilities filters vulnerabilities based on request criteria
func (vs *VulnerabilityV2Service) filterVulnerabilities(vulnerabilities []models.VulnerabilityV2, req types.VulnerabilityV2Request) []models.VulnerabilityV2 {
	var filtered []models.VulnerabilityV2

	for _, vuln := range vulnerabilities {
		// Filter by category
		if req.Category != "" && req.Category != "all" && vuln.Category != req.Category {
			continue
		}

		// Filter by severity
		if req.Severity != "" && req.Severity != "all" && vuln.Severity != req.Severity {
			continue
		}

		// Filter by compliance
		if req.Compliance != "" && req.Compliance != "all" {
			found := false
			for _, framework := range vuln.ComplianceFrameworks {
				if framework == req.Compliance {
					found = true
					break
				}
			}
			if !found {
				continue
			}
		}

		// Filter by agent ID
		if req.AgentID != "" && vuln.AgentID != req.AgentID {
			continue
		}

		// Filter by status
		if req.Status != "" && req.Status != "all" && vuln.Status != req.Status {
			continue
		}

		// Filter by search term
		if req.Search != "" {
			searchLower := strings.ToLower(req.Search)
			if !strings.Contains(strings.ToLower(vuln.Title), searchLower) &&
				!strings.Contains(strings.ToLower(vuln.Description), searchLower) {
				continue
			}
		}

		// Filter by date range
		if req.DateFrom != "" {
			dateFrom, err := time.Parse("2006-01-02", req.DateFrom)
			if err == nil && vuln.DiscoveredAt.Before(dateFrom) {
				continue
			}
		}

		if req.DateTo != "" {
			dateTo, err := time.Parse("2006-01-02", req.DateTo)
			if err == nil && vuln.DiscoveredAt.After(dateTo) {
				continue
			}
		}

		// Filter by tags
		if len(req.Tags) > 0 {
			found := false
			for _, tag := range req.Tags {
				for _, vulnTag := range vuln.Tags {
					if vulnTag == tag {
						found = true
						break
					}
				}
				if found {
					break
				}
			}
			if !found {
				continue
			}
		}

		filtered = append(filtered, vuln)
	}

	return filtered
}

// sortVulnerabilities sorts vulnerabilities based on sort criteria
func (vs *VulnerabilityV2Service) sortVulnerabilities(vulnerabilities []models.VulnerabilityV2, sortBy, sortOrder string) []models.VulnerabilityV2 {
	switch sortBy {
	case "severity":
		sort.Slice(vulnerabilities, func(i, j int) bool {
			severityOrder := map[string]int{
				"critical": 5,
				"high":     4,
				"medium":   3,
				"low":      2,
				"info":     1,
			}
			if sortOrder == "desc" {
				return severityOrder[vulnerabilities[i].Severity] > severityOrder[vulnerabilities[j].Severity]
			}
			return severityOrder[vulnerabilities[i].Severity] < severityOrder[vulnerabilities[j].Severity]
		})
	case "discovered_date":
		sort.Slice(vulnerabilities, func(i, j int) bool {
			if sortOrder == "desc" {
				return vulnerabilities[i].DiscoveredAt.After(vulnerabilities[j].DiscoveredAt)
			}
			return vulnerabilities[i].DiscoveredAt.Before(vulnerabilities[j].DiscoveredAt)
		})
	case "risk_score":
		sort.Slice(vulnerabilities, func(i, j int) bool {
			if sortOrder == "desc" {
				return vulnerabilities[i].RiskScore > vulnerabilities[j].RiskScore
			}
			return vulnerabilities[i].RiskScore < vulnerabilities[j].RiskScore
		})
	}

	return vulnerabilities
}
