"""
Vulnerability Weather Forecasting Service - ML-based threat prediction and forecasting
"""

import asyncio
import json
import logging
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score
import joblib
import os

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class WeatherForecast:
    """Represents a vulnerability weather forecast"""
    organization_id: str
    forecast_id: str
    forecast_period: str  # 7d, 30d, 90d
    high_risk_periods: List[Dict[str, Any]]
    emerging_threats: List[Dict[str, Any]]
    compliance_deadlines: List[Dict[str, Any]]
    threat_velocity: Dict[str, Any]
    risk_trends: List[Dict[str, Any]]
    recommendations: List[str]
    confidence_score: float
    generated_at: str

@dataclass
class HighRiskPeriod:
    """Represents a high-risk period prediction"""
    period_id: str
    start_date: str
    end_date: str
    risk_level: str  # critical, high, medium
    threat_types: List[str]
    affected_technologies: List[str]
    probability: float
    impact_score: float
    mitigation_actions: List[str]

@dataclass
class EmergingThreat:
    """Represents an emerging threat prediction"""
    threat_id: str
    threat_name: str
    threat_type: str
    emergence_probability: float
    impact_potential: str  # critical, high, medium, low
    affected_technologies: List[str]
    timeline: str
    indicators: List[str]
    monitoring_recommendations: List[str]

class VulnerabilityWeatherService:
    """Service for vulnerability weather forecasting and threat prediction"""
    
    def __init__(self):
        self.models = {}
        self.scalers = {}
        self.model_dir = os.path.join(os.path.dirname(__file__), 'weather_models')
        
        # Create models directory if it doesn't exist
        os.makedirs(self.model_dir, exist_ok=True)
        
        # Initialize models
        self._initialize_models()
    
    def _initialize_models(self):
        """Initialize ML models for weather forecasting"""
        try:
            # High-risk period prediction model
            self.models['high_risk_period'] = RandomForestRegressor(
                n_estimators=100,
                max_depth=10,
                random_state=42
            )
            
            # Emerging threat prediction model
            self.models['emerging_threat'] = GradientBoostingRegressor(
                n_estimators=100,
                max_depth=6,
                learning_rate=0.1,
                random_state=42
            )
            
            # Threat velocity prediction model
            self.models['threat_velocity'] = RandomForestRegressor(
                n_estimators=80,
                max_depth=8,
                random_state=42
            )
            
            # Initialize scalers
            self.scalers['standard'] = StandardScaler()
            
            logger.info("Weather forecasting models initialized successfully")
            
        except Exception as e:
            logger.error(f"Error initializing weather models: {e}")
    
    async def generate_weather_forecast(self, organization_id: str, forecast_period: str = "30d",
                                      vulnerability_history: List[Dict] = None,
                                      organization_context: Dict = None) -> WeatherForecast:
        """
        Generate vulnerability weather forecast for an organization
        
        Args:
            organization_id: Organization identifier
            forecast_period: Forecast period (7d, 30d, 90d)
            vulnerability_history: Historical vulnerability data
            organization_context: Organization profile data
        
        Returns:
            WeatherForecast with comprehensive predictions
        """
        try:
            logger.info(f"Generating weather forecast for organization {organization_id}")
            
            # Predict high-risk periods
            high_risk_periods = await self._predict_high_risk_periods(
                organization_id, forecast_period, vulnerability_history, organization_context
            )
            
            # Predict emerging threats
            emerging_threats = await self._predict_emerging_threats(
                organization_id, forecast_period, vulnerability_history, organization_context
            )
            
            # Identify compliance deadlines
            compliance_deadlines = await self._identify_compliance_deadlines(
                organization_id, forecast_period, organization_context
            )
            
            # Calculate threat velocity
            threat_velocity = await self._calculate_threat_velocity(
                vulnerability_history, forecast_period
            )
            
            # Analyze risk trends
            risk_trends = await self._analyze_risk_trends(
                vulnerability_history, forecast_period
            )
            
            # Generate recommendations
            recommendations = await self._generate_weather_recommendations(
                high_risk_periods, emerging_threats, compliance_deadlines, threat_velocity
            )
            
            # Calculate confidence score
            confidence_score = await self._calculate_forecast_confidence(
                vulnerability_history, high_risk_periods, emerging_threats
            )
            
            # Create weather forecast
            forecast = WeatherForecast(
                organization_id=organization_id,
                forecast_id=f"weather_{organization_id}_{int(datetime.now().timestamp())}",
                forecast_period=forecast_period,
                high_risk_periods=high_risk_periods,
                emerging_threats=emerging_threats,
                compliance_deadlines=compliance_deadlines,
                threat_velocity=threat_velocity,
                risk_trends=risk_trends,
                recommendations=recommendations,
                confidence_score=confidence_score,
                generated_at=datetime.utcnow().isoformat()
            )
            
            logger.info(f"Completed weather forecast for organization {organization_id}")
            return forecast
            
        except Exception as e:
            logger.error(f"Error generating weather forecast: {e}")
            return self._get_fallback_forecast(organization_id, forecast_period)
    
    async def _predict_high_risk_periods(self, organization_id: str, forecast_period: str,
                                       vulnerability_history: List[Dict], organization_context: Dict) -> List[Dict[str, Any]]:
        """Predict high-risk periods for the organization"""
        try:
            high_risk_periods = []
            
            # Mock high-risk period prediction
            # In a real implementation, this would use ML models trained on historical data
            
            # Generate mock high-risk periods based on forecast period
            days_to_forecast = self._get_days_from_period(forecast_period)
            
            # Simulate high-risk periods
            if days_to_forecast >= 7:
                # Week 1 high-risk period
                high_risk_periods.append({
                    'period_id': f"hrp_{organization_id}_1",
                    'start_date': (datetime.now() + timedelta(days=2)).isoformat(),
                    'end_date': (datetime.now() + timedelta(days=5)).isoformat(),
                    'risk_level': 'high',
                    'threat_types': ['Web Application Attacks', 'Database Vulnerabilities'],
                    'affected_technologies': ['Web Servers', 'Database Systems'],
                    'probability': 0.75,
                    'impact_score': 0.8,
                    'mitigation_actions': [
                        'Implement additional monitoring',
                        'Review and update security controls',
                        'Prepare incident response procedures'
                    ]
                })
            
            if days_to_forecast >= 30:
                # Month 1 critical period
                high_risk_periods.append({
                    'period_id': f"hrp_{organization_id}_2",
                    'start_date': (datetime.now() + timedelta(days=15)).isoformat(),
                    'end_date': (datetime.now() + timedelta(days=22)).isoformat(),
                    'risk_level': 'critical',
                    'threat_types': ['Zero-Day Exploits', 'Advanced Persistent Threats'],
                    'affected_technologies': ['All Systems'],
                    'probability': 0.6,
                    'impact_score': 0.9,
                    'mitigation_actions': [
                        'Activate emergency response procedures',
                        'Implement enhanced monitoring',
                        'Prepare for potential incidents',
                        'Review and update security policies'
                    ]
                })
            
            if days_to_forecast >= 90:
                # Quarter 1 high-risk period
                high_risk_periods.append({
                    'period_id': f"hrp_{organization_id}_3",
                    'start_date': (datetime.now() + timedelta(days=60)).isoformat(),
                    'end_date': (datetime.now() + timedelta(days=67)).isoformat(),
                    'risk_level': 'high',
                    'threat_types': ['Supply Chain Attacks', 'Insider Threats'],
                    'affected_technologies': ['Third-party Integrations', 'Internal Systems'],
                    'probability': 0.5,
                    'impact_score': 0.7,
                    'mitigation_actions': [
                        'Review third-party security',
                        'Implement insider threat detection',
                        'Enhance supply chain monitoring'
                    ]
                })
            
            return high_risk_periods
            
        except Exception as e:
            logger.error(f"Error predicting high-risk periods: {e}")
            return []
    
    async def _predict_emerging_threats(self, organization_id: str, forecast_period: str,
                                     vulnerability_history: List[Dict], organization_context: Dict) -> List[Dict[str, Any]]:
        """Predict emerging threats for the organization"""
        try:
            emerging_threats = []
            
            # Mock emerging threat prediction
            # In a real implementation, this would analyze threat intelligence and vulnerability trends
            
            # Simulate emerging threats based on organization context
            if organization_context:
                industry = organization_context.get('industry', 'technology')
                tech_stack = organization_context.get('tech_stack', {})
                
                # Industry-specific emerging threats
                if industry.lower() == 'healthcare':
                    emerging_threats.append({
                        'threat_id': f"et_{organization_id}_1",
                        'threat_name': 'Healthcare IoT Device Exploitation',
                        'threat_type': 'IoT Security',
                        'emergence_probability': 0.7,
                        'impact_potential': 'high',
                        'affected_technologies': ['IoT Devices', 'Medical Equipment'],
                        'timeline': '30-60 days',
                        'indicators': [
                            'Increased IoT device vulnerabilities',
                            'Healthcare-specific attack campaigns',
                            'Medical device security incidents'
                        ],
                        'monitoring_recommendations': [
                            'Monitor IoT device security',
                            'Implement medical device security controls',
                            'Track healthcare threat intelligence'
                        ]
                    })
                
                elif industry.lower() == 'finance':
                    emerging_threats.append({
                        'threat_id': f"et_{organization_id}_2",
                        'threat_name': 'AI-Powered Financial Fraud',
                        'threat_type': 'AI Security',
                        'emergence_probability': 0.6,
                        'impact_potential': 'critical',
                        'affected_technologies': ['AI/ML Systems', 'Financial APIs'],
                        'timeline': '45-90 days',
                        'indicators': [
                            'AI model vulnerabilities',
                            'Financial fraud patterns',
                            'Machine learning security incidents'
                        ],
                        'monitoring_recommendations': [
                            'Monitor AI model security',
                            'Implement fraud detection',
                            'Track AI security threats'
                        ]
                    })
            
            # Technology-specific emerging threats
            if tech_stack:
                languages = tech_stack.get('languages', [])
                if 'python' in [lang.lower() for lang in languages]:
                    emerging_threats.append({
                        'threat_id': f"et_{organization_id}_3",
                        'threat_name': 'Python Package Supply Chain Attacks',
                        'threat_type': 'Supply Chain',
                        'emergence_probability': 0.8,
                        'impact_potential': 'high',
                        'affected_technologies': ['Python Applications', 'Package Managers'],
                        'timeline': '15-30 days',
                        'indicators': [
                            'Malicious Python packages',
                            'Package manager vulnerabilities',
                            'Supply chain attack campaigns'
                        ],
                        'monitoring_recommendations': [
                            'Monitor package dependencies',
                            'Implement package verification',
                            'Track supply chain threats'
                        ]
                    })
            
            # General emerging threats
            emerging_threats.append({
                'threat_id': f"et_{organization_id}_4",
                'threat_name': 'Cloud-Native Security Exploits',
                'threat_type': 'Cloud Security',
                'emergence_probability': 0.6,
                'impact_potential': 'medium',
                'affected_technologies': ['Cloud Infrastructure', 'Container Systems'],
                'timeline': '60-90 days',
                'indicators': [
                    'Container security vulnerabilities',
                    'Cloud service exploits',
                    'Kubernetes security incidents'
                ],
                'monitoring_recommendations': [
                    'Monitor cloud security',
                    'Implement container security',
                    'Track cloud threat intelligence'
                ]
            })
            
            return emerging_threats
            
        except Exception as e:
            logger.error(f"Error predicting emerging threats: {e}")
            return []
    
    async def _identify_compliance_deadlines(self, organization_id: str, forecast_period: str,
                                          organization_context: Dict) -> List[Dict[str, Any]]:
        """Identify compliance deadlines and requirements"""
        try:
            compliance_deadlines = []
            
            if not organization_context:
                return compliance_deadlines
            
            compliance_frameworks = organization_context.get('compliance_frameworks', [])
            industry = organization_context.get('industry', '')
            
            # Generate compliance deadlines based on frameworks
            for framework in compliance_frameworks:
                if framework.upper() == 'HIPAA':
                    compliance_deadlines.append({
                        'framework': 'HIPAA',
                        'deadline_type': 'Annual Risk Assessment',
                        'deadline_date': (datetime.now() + timedelta(days=30)).isoformat(),
                        'priority': 'high',
                        'requirements': [
                            'Conduct comprehensive risk assessment',
                            'Update security policies',
                            'Review access controls'
                        ],
                        'preparation_time': '14 days'
                    })
                
                elif framework.upper() == 'PCI DSS':
                    compliance_deadlines.append({
                        'framework': 'PCI DSS',
                        'deadline_type': 'Quarterly Security Review',
                        'deadline_date': (datetime.now() + timedelta(days=45)).isoformat(),
                        'priority': 'high',
                        'requirements': [
                            'Review payment card security',
                            'Update security controls',
                            'Conduct vulnerability assessment'
                        ],
                        'preparation_time': '21 days'
                    })
                
                elif framework.upper() == 'SOX':
                    compliance_deadlines.append({
                        'framework': 'SOX',
                        'deadline_type': 'Annual IT Controls Review',
                        'deadline_date': (datetime.now() + timedelta(days=60)).isoformat(),
                        'priority': 'medium',
                        'requirements': [
                            'Review IT controls',
                            'Update control documentation',
                            'Conduct control testing'
                        ],
                        'preparation_time': '30 days'
                    })
            
            # Industry-specific deadlines
            if industry.lower() == 'healthcare':
                compliance_deadlines.append({
                    'framework': 'HITECH',
                    'deadline_type': 'Security Incident Review',
                    'deadline_date': (datetime.now() + timedelta(days=20)).isoformat(),
                    'priority': 'high',
                    'requirements': [
                        'Review security incidents',
                        'Update incident response procedures',
                        'Conduct security training'
                    ],
                    'preparation_time': '10 days'
                })
            
            return compliance_deadlines
            
        except Exception as e:
            logger.error(f"Error identifying compliance deadlines: {e}")
            return []
    
    async def _calculate_threat_velocity(self, vulnerability_history: List[Dict], forecast_period: str) -> Dict[str, Any]:
        """Calculate threat velocity and trends"""
        try:
            # Mock threat velocity calculation
            # In a real implementation, this would analyze historical vulnerability data
            
            days_to_forecast = self._get_days_from_period(forecast_period)
            
            # Simulate threat velocity metrics
            current_velocity = 0.6  # 0-1 scale
            predicted_velocity = 0.7  # Predicted velocity
            
            # Calculate velocity trend
            if predicted_velocity > current_velocity:
                velocity_trend = 'increasing'
            elif predicted_velocity < current_velocity:
                velocity_trend = 'decreasing'
            else:
                velocity_trend = 'stable'
            
            # Calculate threat indicators
            threat_indicators = {
                'vulnerability_discovery_rate': 0.8,
                'exploit_development_rate': 0.6,
                'attack_surface_growth': 0.7,
                'threat_intelligence_volume': 0.9
            }
            
            # Calculate overall threat velocity score
            velocity_score = np.mean(list(threat_indicators.values()))
            
            return {
                'current_velocity': current_velocity,
                'predicted_velocity': predicted_velocity,
                'velocity_trend': velocity_trend,
                'velocity_score': velocity_score,
                'threat_indicators': threat_indicators,
                'risk_level': 'high' if velocity_score > 0.7 else 'medium' if velocity_score > 0.4 else 'low',
                'forecast_period': forecast_period
            }
            
        except Exception as e:
            logger.error(f"Error calculating threat velocity: {e}")
            return {
                'current_velocity': 0.5,
                'predicted_velocity': 0.5,
                'velocity_trend': 'stable',
                'velocity_score': 0.5,
                'threat_indicators': {},
                'risk_level': 'medium',
                'forecast_period': forecast_period
            }
    
    async def _analyze_risk_trends(self, vulnerability_history: List[Dict], forecast_period: str) -> List[Dict[str, Any]]:
        """Analyze risk trends and patterns"""
        try:
            risk_trends = []
            
            # Mock risk trend analysis
            # In a real implementation, this would analyze historical data and patterns
            
            # Severity trend
            risk_trends.append({
                'trend_type': 'severity',
                'direction': 'increasing',
                'magnitude': 0.15,
                'confidence': 0.8,
                'description': 'Critical and high severity vulnerabilities are increasing',
                'impact': 'high'
            })
            
            # Technology trend
            risk_trends.append({
                'trend_type': 'technology',
                'direction': 'stable',
                'magnitude': 0.05,
                'confidence': 0.7,
                'description': 'Technology risk distribution remains stable',
                'impact': 'medium'
            })
            
            # Temporal trend
            risk_trends.append({
                'trend_type': 'temporal',
                'direction': 'cyclical',
                'magnitude': 0.3,
                'confidence': 0.9,
                'description': 'Risk follows seasonal patterns with peaks in Q1 and Q3',
                'impact': 'medium'
            })
            
            # Compliance trend
            risk_trends.append({
                'trend_type': 'compliance',
                'direction': 'increasing',
                'magnitude': 0.2,
                'confidence': 0.85,
                'description': 'Compliance-related vulnerabilities are increasing',
                'impact': 'high'
            })
            
            return risk_trends
            
        except Exception as e:
            logger.error(f"Error analyzing risk trends: {e}")
            return []
    
    async def _generate_weather_recommendations(self, high_risk_periods: List[Dict], emerging_threats: List[Dict],
                                             compliance_deadlines: List[Dict], threat_velocity: Dict) -> List[str]:
        """Generate recommendations based on weather forecast"""
        recommendations = []
        
        try:
            # High-risk period recommendations
            if high_risk_periods:
                critical_periods = [p for p in high_risk_periods if p.get('risk_level') == 'critical']
                if critical_periods:
                    recommendations.append("Prepare for critical risk periods with enhanced monitoring")
                    recommendations.append("Activate emergency response procedures")
                
                high_periods = [p for p in high_risk_periods if p.get('risk_level') == 'high']
                if high_periods:
                    recommendations.append("Implement additional security controls for high-risk periods")
                    recommendations.append("Review and update incident response procedures")
            
            # Emerging threat recommendations
            if emerging_threats:
                high_impact_threats = [t for t in emerging_threats if t.get('impact_potential') in ['critical', 'high']]
                if high_impact_threats:
                    recommendations.append("Monitor emerging high-impact threats closely")
                    recommendations.append("Implement proactive threat detection")
                
                recommendations.append("Stay updated on emerging threat intelligence")
                recommendations.append("Implement threat-specific security controls")
            
            # Compliance deadline recommendations
            if compliance_deadlines:
                high_priority_deadlines = [d for d in compliance_deadlines if d.get('priority') == 'high']
                if high_priority_deadlines:
                    recommendations.append("Prioritize high-priority compliance deadlines")
                    recommendations.append("Allocate resources for compliance preparation")
                
                recommendations.append("Review compliance requirements and prepare documentation")
                recommendations.append("Schedule compliance review meetings")
            
            # Threat velocity recommendations
            velocity_score = threat_velocity.get('velocity_score', 0.5)
            if velocity_score > 0.7:
                recommendations.append("Implement enhanced threat monitoring due to high threat velocity")
                recommendations.append("Consider increasing security team capacity")
            elif velocity_score < 0.3:
                recommendations.append("Maintain current security posture with regular monitoring")
            
            # General recommendations
            recommendations.extend([
                "Regular review of weather forecast updates",
                "Continuous monitoring of threat landscape",
                "Proactive security posture adjustments"
            ])
            
        except Exception as e:
            logger.error(f"Error generating weather recommendations: {e}")
            recommendations = [
                "Monitor threat landscape regularly",
                "Maintain proactive security posture",
                "Review and update security controls"
            ]
        
        return recommendations
    
    async def _calculate_forecast_confidence(self, vulnerability_history: List[Dict], 
                                          high_risk_periods: List[Dict], emerging_threats: List[Dict]) -> float:
        """Calculate confidence score for the weather forecast"""
        try:
            base_confidence = 0.7
            
            # Adjust based on historical data availability
            if vulnerability_history and len(vulnerability_history) > 100:
                base_confidence += 0.1
            elif vulnerability_history and len(vulnerability_history) > 50:
                base_confidence += 0.05
            
            # Adjust based on prediction complexity
            if len(high_risk_periods) > 3:
                base_confidence -= 0.1  # More predictions = lower confidence
            
            if len(emerging_threats) > 5:
                base_confidence -= 0.05
            
            # Adjust based on data quality
            if vulnerability_history:
                complete_records = sum(1 for vuln in vulnerability_history 
                                     if vuln.get('severity') and vuln.get('created_at'))
                quality_ratio = complete_records / len(vulnerability_history)
                base_confidence += quality_ratio * 0.15
            
            return min(max(base_confidence, 0.0), 1.0)
            
        except Exception as e:
            logger.error(f"Error calculating forecast confidence: {e}")
            return 0.5
    
    def _get_days_from_period(self, period: str) -> int:
        """Convert forecast period to days"""
        if period == "7d":
            return 7
        elif period == "30d":
            return 30
        elif period == "90d":
            return 90
        else:
            return 30  # Default to 30 days
    
    def _get_fallback_forecast(self, organization_id: str, forecast_period: str) -> WeatherForecast:
        """Get fallback forecast when analysis fails"""
        return WeatherForecast(
            organization_id=organization_id,
            forecast_id=f"fallback_{organization_id}_{int(datetime.now().timestamp())}",
            forecast_period=forecast_period,
            high_risk_periods=[],
            emerging_threats=[],
            compliance_deadlines=[],
            threat_velocity={
                'current_velocity': 0.5,
                'predicted_velocity': 0.5,
                'velocity_trend': 'stable',
                'velocity_score': 0.5,
                'risk_level': 'medium'
            },
            risk_trends=[],
            recommendations=[
                "Monitor threat landscape regularly",
                "Maintain proactive security posture",
                "Review security controls periodically"
            ],
            confidence_score=0.3,
            generated_at=datetime.utcnow().isoformat()
        )

# Global vulnerability weather service instance
vulnerability_weather_service = VulnerabilityWeatherService()

